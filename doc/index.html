<html>
<title>Transformenator</title>
<a href="http://sourceforge.net/projects/transformenator/files/"><img src="xfmn.png"></a>
<h1>Transformenator <a href="http://sourceforge.net/projects/transformenator/files/">(Download)</a></h1>
Transformenation is something that should be possible to do with some rudimentary shell scripting.  
You should be able to run a binary file through sed or awk and have byte sequences change to different byte sequences.  
<p>
But you can't.
<p>
You could probably run a file through a hex dumper, change hex values, then un-transform it back to binary.
But that's kind of a pain too.  
The problem is that sed and awk work on lines, defined as things that are delineated by what they consider line ending characters like 0x0d or 0x0a.
But what if your data stream contains 0x0d and 0x0a bytes - but you don't want them to count as line endings?
What if you need to remove nulls, hex zeroes, or whatever you want to call them from a binary file or data stream?
<p>
Your're stuck.
<p>
Maybe that's why you're here.
Transformenator can help.
<p>
<h2>Useage</h2>
Invoke the transformenator Java jar file from any command line, ant script, or what have you.
A set of rules (comprising a transform) are applied to the input file and written to the output file.
Several sample transforms are included in the distribution jar file, and you can write your own as simply as creating a text file.
<p>
For example:
<xmp>
java -jar transformenator.jar transform infile.bin outfile.bin
</xmp>
<p>
Where:<br>
<code>transform</code> is a file containing the set of transformations you want to make<br>
<code>infile.bin</code> is the original file<br>
<code>outfile.bin</code> is the resulting file after running the transforms
<h2>Example</h2>
Say you have the file below named infile.bin, represented in a typical hex editor:
<xmp>(Offset) (Hex data)                               (ASCII representation)
0000000: 6162 6364 0000 6566 6768 696a 1a67 6574  abcd..efghij.get
0000010: 2072 6964 206f 6620 6d65 210a             rid of me!.
</xmp>
Say we want to change the hex zeroes in the middle to spaces, and eliminate anything after the EOF (0x1a).
Create a transform file named transform to do that:
<xmp>; Make nulls into spaces
00 = 20
; ASCII EOF character really means EOF
1a = "{@@<FiLe_EoF>@@}"</xmp>
So, we run infile.bin through the transform file and send the output to a file named outfile.bin:
<xmp>%java -jar transformenator.jar transform infile.bin outfile.bin</xmp>
The resulting outfile.bin looks like this in a hex editor:
<xmp>(Offset) (Hex data)                               (ASCII representation)
0000000: 6162 6364 2020 6566 6768 696a            abcd  efghij</xmp>
Observe that nulls became spaces, and other trailing stuff after the EOF character has been removed.
<h2>Transform Specifications</h2>
The Transformenator project comes with several example transforms used to convert various early binary word processor
formats to RTF, HTML, or plain ASCII text. 
A sample <code>transform</code> file might simply look like this:
<xmp>; Change 0x00 to 0x20
00 = 20</xmp>
It may be desirable to continue processing a data stream including a substitution that has just been made - exposing it to further processing by subsequent specifications.
The "hash" ("#") character is used instead of the equals sign in that case:
<xmp>; Add a newline - may need to add an additional one
8d # 0d0a
0d0a9d = 0d0a0d0a</xmp>
Note that replacement bytes that are "fed back" this way can form a tight loop with itself and subsequent specifications.  
For example, this production will never complete:
<xmp>20 # 20</xmp>
<p>
Sometimes it is desirable to "toggle" between two output values when a particular byte sequence is encountered.
Some word processors, for example, have a single byte sequence that signifies to start and stop a particular attribute.
For these situations, the percent sign ("%") character is used, and the two toggling values are separated by a comma:
<xmp>; Toggle italics on and off
7f047f % "\i1 ","\i0 "</xmp>
<p>
Semicolons denote comment lines.
<xmp>; This is a comment</xmp>
The left side of the equals sign, hash mark, or percent sign is one of these things:
<ul>
<li>A byte pattern, given in even numbers of hex digits, with no other decoration<br>
<xmp>0d0a32ea4f</xmp>
<li>A byte pattern combined with "don't care" values consisting of even numbers of non-hex digits (periods/full stops are preferred but not enforced)<br>
<xmp>0d0a....4f</xmp>
<li>A byte pattern combined with "must not be zero" values consisting of even numbers of exclamation points<br>
<xmp>0d0a32!!4f</xmp>
</ul>
The right side can be blank, another byte pattern given in undecorated hex, or ASCII text if surrounded in double quotes.
Examples:
<xmp>; Hard newline
8d = 0d0a
; 0x86 appeared at the beginning of files sometimes, after the preamble.  Remove it.
86 =
; Start of heading
83 = "\par\par\pard\s2\b\fs36 "
; Italics on
b12d31 = "\i "
; Italics off
b12d30 = "\i0 "
</xmp>
Some special processing can take place:
<ul>
<li>A byte range can be shifted byte-for-byte to a different range starting at the value after the equals sign, or removed altogether:<br>
<xmp>;Shift 0x41 through 0x5a up to 0x61
[41..5a] = 61
; Remove 0xf0 through 0xff
[f0..ff] = </xmp>
<li><code>head</code> specifies a beginning-of-file prefix to add to the beginning of the resultant file:<br>
<xmp>; Header for HTML format
head = "<html>"</xmp>
<li><code>tail</code> specifies a end-of-file suffix to add to the end of the resultant file:<br>
<xmp>; Trailer for HTML format
tail = "</html>"</xmp>
<li><code>trim-leading</code> specifies a number of bytes to trim off the beginning of the input file (in hex bytes) <u>before</u> any binary transforms are applied:<br>
<xmp>; Trim the leading 0x400 bytes - this is a Pascal format file
trim_leading = 0400</xmp>
<li><code>regex</code> specifies a regular expression to run on the output <u>after</u> any and all binary transforms are applied;
multiple <code>regex</code> expressions are allowed, one per line:<br>
<xmp>; Remove left/right margin specs: zlmxx, :rmxx
regex = @[z|:][l|r]m[0-9]*@@
; Remove next file specification
regex = @znx:.*@@</xmp>
Regular expressions are surrounded by delimiters - the first character in the string serves as that delimiter.
So the production <code>regex=$abc$123$</code> will use <code>$</code> as the delimiter, and replace all occurrences of <code>abc</code> with <code>123</code>.
</ul>
There are special cases for representing the beginning and the end of a file. 
When specifying the byte pattern that signifies the beginning of the file, the right side must be the production in the example below:
<xmp>; SOF is \r\nS
0d0a53 = "{@@<FiLe_SoF>@@}"</xmp> 
When specifying the byte pattern that signifies the end of file marker, the right side must be the production in the example below:
<xmp>; EOF is ctrl-Z
1a = "{@@<FiLe_EoF>@@}"</xmp> 
There is a special case for specifying returns and newlines.
If you need to translate a byte pattern into something that includes them, you need to escape the backslash.
For example:
<xmp>; Justify on
7a0a1531 = "\\r\\n</pre>"</xmp>

<h2>Related Projects</h2>
Binary Block Editor (<a href="http://bbe-.sourceforge.net/">bbe</a>) is a related sed-like editor for binary files.

<h2>Transformenator Project Page at SourceForge</h2>
<a href="http://sourceforge.net/projects/transformenator"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=170262&amp;type=13" width="120" height="30" alt="Get Transformenator at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a>

<!-- Just a little evil... let our friends at the Google track page hits -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-697468-5']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>